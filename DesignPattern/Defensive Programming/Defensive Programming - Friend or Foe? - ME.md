# Defensive Programming - Friend or Foe? - ME

원문 : [Defensive Programming - Friend or Foe?](https://interrupt.memfault.com/blog/defensive-and-offensive-programming#handling-external--application-code)

# 선 요약

공격적 프로그래밍

* 값, 타입에 대해서 예외처리를 두지 않고 모두 ASSERT

    * ASSERT를 하면서 디버깅을 위해 트레이스 백, 코어 덤프, 로깅, 등으로 디버깅을 수월하게 해주는 것도 필수
    
* 펌웨어와 같이 한번 에러가 발생하면 시스템 전체가 무너질 수 있는 **근본**이 되는  프로그래밍에 적합

    * 한번 릴리스 후, 사후 지원 및 업데이트가 힘든 제품의 경우 더더욱 해당

* 위와 같은 특성 때문에 테스트/개발 단계에서 쓰이는 적합한 패턴

방어적 프로그래밍

* 공격적 프로그래밍을 적용한 테스트/개발 단계에서 조차 발견하지 못했을 에러를 감안하고 예외처리를 한 프로그래밍

    * ASSERT 구문을 예외처리문으로 바꾸는 매크로로 정의해서 처리할 것
    
    * 출시되는 제품의 디바이스 또는 소프트웨어에 따라 디버깅을 하기위한 로그를 남길 수 있으면 남길것

공격적 프로그래밍 -> 테스트 개발 단계

방어적 프로그래밍 -> 출시 단계

# 주저리 주저리

방어적 프로그래밍에 대해서 알게된 것은 계약에 의한 프로그래밍(Programming By Contract)의 연관 내용으로 올라왔기 때문이다.

방어적 프로그래밍, 계약에 의한 프로그래밍 모두 프로그램을 만드는 제작자와 그 프로그램을 이용하는 외부 사용자 사이에 벌어질 수 있는 문제로부터 뿌리를 둔다.

* 방어적 프로그래밍은 개발 단계부터 이후 디버깅을 더 중점으로 두는 *수동적인* 프로그래밍 방식

* 계약에 의한 프로그래밍은 방어할 순간조차 안 만드는, 적극적인(Aggressive) 프로그래밍 방식

처음에는 이렇게 단순하게 '느낌'대로 그 차이를 구분했지만, 원문을 읽고 번역하면서 쓰이는 방식과 장소에 차이가 있음을 알게되었다.

방어적 프로그래밍은 출시 이후 빠른 후속조치가 힘들거나, 작은 문제가 발생하면 큰 파장이 일어날 수 있는<br>
낮은 수준의 프로그래밍(임베디드, 펌웨어, 등)에서 다루는 개념이고

계약에 의한 프로그래밍은 높은 수준의 프로그래밍에서 그 조건을 더 추상화하여, '값의 범위', '값의 타입'과 같이<br>
인간이 다루는 수치(눈에 보이는 그대로, 10과 10.0을 구분하지 않는)를 다루는 개념으로 한번 더 정리했다.

계약에 의한 프로그래밍이 C#과 동적인 언어에서 많이 사용되는 점도 그렇고 동적인 환경(런타임)에서 작동하는 것처럼

동작하는 시간대가 다르기 때문에 단순히 1:1로 비교할 수 없는 개념이었기 때문이다.

<br>

마치 내가 전에 오버라이딩(Overriding)과 멀티 디스패치(Multi-Dispatch)를 비슷한 개념으로 혼동할 때

외관상으로 봤을 떄 프로그램이 동작하는 방식이 비슷해보이지만,

그 원리를 들여다보면 발현되는 시점과 방법 자체가 아예 다른것처럼

프로그래밍 방법론과 프로그래밍 언어가 갖고 있는 기능에 대해서 알아볼 때 단순히 그 사용방법뿐만 아니라

만들어진 원리와 만든 사람이 의도한 것들에 대해서 파악하는 기회를 나 스스로 만들어주는 글이 되었다.