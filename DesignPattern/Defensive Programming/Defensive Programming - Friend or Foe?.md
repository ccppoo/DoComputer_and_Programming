# Defensive Programming - Friend or Foe?

by Tyler Hoffman

원본 링크 : [Defensive Programming - Friend or Foe?](https://interrupt.memfault.com/blog/defensive-and-offensive-programming)

# 방어적 프로그래밍 - 친구일까 적일까?

임베딩 개발(특히 C언에서)을 하면서 제일 최악의 경우 중 하나는 함수를 실행하고 그 반환값으로 아무런 정보없이 `-1` 또는 `unknown_error`를 받는 것입니다.<br>
이 에러가 어디서, 언제 일어났는지 말도 없이 단지 에러가 났다고만 말하는 겁니다!

임베딩 개발자이라면 한번쯤은 새로운 보드, 드라이버, 모듈, 그리고 앱까지 이 지경까지 도달했는지 헤맸을 경험이 있을겁니다.<br>
근본적인 원인을 찾아 모듈을 하나씩 뒤져보는 것은 마치 양파를 까는 것과 같습니다.<br>
디버깅을 하면서 이게 뭔지, 왜 이러는 건지 웃음은 사라지고 점점 눈물과 짜증만 치밀어 오르죠.<br>

이런 이슈들은 대부분 프레임워크를 사용하는 개발자로 인해 발생한 에러의 결과물입니다.<br>
함수를 순서대로 또는 제때 호출하지 않거나, 형식에 맞지 않는 인자가 주어지는 경우 또는 메모리가 부족하거나 데드락(dead-lock) 상태인 경우 시스템 자체에 문제가 있어 일어날 수도 있죠.

펌웨어의 입장에선 문제가 발생했고, 어떤 문제인지 알지만, 문제를 해결하는데 도움은 주지 않습니다.<br>
**방어적 프로그래밍**(Defensive Programming)을 했기 때문에, 문제가 발생해도 돌아게끔 했기 때문입니다.

저는 문제가 발생했음에도 조용히 넘어가는 것보단 차라리 펌웨어 크래시(crash)가 일어나거나, 유의미한 에러와 트레이스 백(traceback)을 출력해서 정확히 어디서, 어떤 이슈가 일어났는지 알려주는 것을 선호합니다.<br>
에러가 났으면 적극적으로 알리고,  아예 펌웨어가 정지하도록 설계한 **공격적 프로그래밍**(Offensive Programming)에 대해서 설명해드리겠습니다.

이 글에서는 크게 네 가지 내용으로 구성되어 있습니다

* **방어적 프로그래밍과 공격적 프로그래밍이란 무엇인가**

* **방어적 프로그래밍의 단점은 무엇인가**

* **임베딩에서 공격적 프로그래밍을 사용할 때 어떤점을 유의해야하는가**

* **공격적 프로그래밍이 어떻게 개발자에게 런타임 도중 버그를 노출시키고 알려줄 수 있는가**

방어적/공격적 프로그래밍에 대해서 알게되면 보지 못한 버그를 재현하는데 고생을 덜 수 있으며, 생산성 증대에 큰 도움이 될 것입니다.

## 목차

* 방어적 프로그래밍

    * 방어적 프로그래밍의 단점
    
* 공격적 프로그래밍

    * 공격적 프로그래밍의 장점
    
* 공격적 프로그래밍 실습

    * 함수의 인자 평가하기
    
    * 리소스 고갈 대처하기
    
    * 소프트웨어 정지와 데드락
    
    * Use After Free Bugs
    
    * State Transition Errors
    
    * 프로그래머에 의한 컴파일 타임 에러
    
* 외부 입력 및 상황과 애플리케이션 코드 핸들링

* 모범 예시

    * Don't Assert on Boot Sequences
    
    * Playing Offense Internally
    
    * Playing Offense in Production Builds

* 결론

<br>

## 방어적 프로그래밍 

방어적 프로그래밍은 예상에 없던 문제가 발생하거나, 발생하는 도중에도 소프트웨어가 계속해서 잘 실행될 수 있도록 하는 프로그래밍 설계 방식입니다.

아래 예시 코드는 `malloc()`을 호출한 뒤 `NULL`을 반환했는지 확인하고, `NULL`을 반환했을 경우 애플리케이션이 계속해서 작동할 수 있도록 처리합니다.

```c
void do_something(void) {
  uint8_t *buf = malloc(128);
  if (buf == NULL) {
    // 알아서 잘 처리하기!
  }
}
```

방어적 프로그래밍은 듣기만하면 좋습니다, 실제로 좋기도 하고요!<br>

외부로 유통된 펌웨어는 예상하지 못한 문제로 인한 재앙으로 무너져선 안됩니다.

방어적 프로그래밍은 개발자가 **제어할 수 없는 상황**인 하드웨어, 외부 라이브러리, 외부 입력과 상호작용하는 순간에서 능력을 발휘합니다.<br>
하드웨어는 결함을 가질수 있고 다른 환경에서 다르게 작동할 수 있고, *무거운* 라이브러리는 버그투성이고, 외부 입력으로부터 이상한 것만 들어옵니다.

방어적 프로그래밍은 예외 상황으로 인해 발생하는 문제로부터 안전해질 수 있다는 인식으로 남용될 가능성이 높습니다.

방어적 프로그램이 쌓이고 쌓이면 발생하는 예외와 버그들은 조치를 취하지 못하면서, 더 추상화된 API 단계에서 접하는 에러는 고칠 가능성 조차 없어지게 됩니다.

문제가 발생해도 사라지고, 무시됩니다. 추적조차 할 수 없겠죠.

<br>

### 방어적 프로그래밍의 단점

방어적 프로그래밍을 사용하는 주요 대상은 펌웨어 외부로 노출되는 인터페이스입니다.<br>
**외부에 노출되는 인터페이스**는 간단하지만, 든든한 벽 같은 방어적 프로그래밍이 되어 있어야합니다.<br>
반대로 외부에서 접근할 수 없는 **내부 코드**는 더욱 공격적으로 예외 상황 또는 에러가 발생할 경우 assert 하는 환경이 조성되어야합니다.

<!-- https://interrupt.memfault.com/blog/img/defensive-and-offensive-programming/internal-software.png -->

<!-- 사진 주석 : If code paths originate from or pass through the red zones, then defensive programming is a good approach. -->

제어를 할 수 **없는** 외부로부터 입력에 대해서는 관대하게,<br>
제어를 할 수 **있는** 내부에서는 엄격하게 관리해야하는 것이죠.

예를 들어, 문자열과 길이를 받고 해싱(hash)을 해 주는 함수 `hash32_djb2`가 있다고 가정합시다.<br>
이 함수는 외부에서 접근할 수 없는 private한 코드 입니다.

```c
uint32_t hash32_djb2(const char *str, int len){
  if (str == NULL) {
    // Invalid arguemnt
    return 0;
  }
  ...
}
```

이런 코드는 스스로 해치는 코드와 다름 없습니다. 

예외 상황으로 문자열 참조 인자 `*str`에 `NULL`이 주어졌음에도 불구하고, 예상된 반환 타입, `uint32_t`인 '0'을 반환했기 때문이죠.

`hash32_djb2()` 함수를 사용하는 모든 코드는 '0'을 반환 받아도 정상적으로 코드가 실행되었다고 인식할 수 있습니다.

내부적으로 사용되는 코드(역주 : 외부에 노출되지 않는 private property)는 개발자 자체의 버그이고, **즉시** 고쳐야합니다.<br>
개발자가 스스로 발생한 버그를 눈 앞에서 보고, 고치지도 않고 아무렇지 않게 '예외처리'를 한다는 것이 말이 됩니까?

문제가 발생했다고  반환값으로  `NULL`, `-1`, `(Empty String)`, 등을 반환해서 알려주는 것과 반대로<br>
문제가 발생하면 코드 자체적으로 처리하는 것이 아닌, 프로그램을 중단시켜 개발자에게 문제가 발생했을을 알리는,<br>
**적극적**으로 알리는 프로그래밍 방식이 "**공격적 프로그래밍**"(Offensive Programming) 입니다.

## 공격적 프로그래밍

공격적 프로그래밍이라는 단어를 봤을 때 방어적 프로그래밍과 정반대의 개념처럼 보일 수 있지만, 방어적 프로그래밍을 확장한 개념에 가깝습니다.
지금 당장 마음에 와닿지 않더라도 결국 방어적, 공격적 프로그래밍은 같은 원초적으로 목표를 두고 있다는 것을 느낄 수 있을 겁니다.

> Attack is the Best Defence - 선즉제인(先則制人)

방어적 프로그래밍 목차에서 본 예시에서, 공격적 프로그래밍은 `malloc()` 함수가 단순히 실패할 수 있다는 것을 그대로 묵인하지 않습니다.<br>
`malloc()` 함수가 메모리 확보에 실패하면 곧 바로 `assert`를 한 뒤 개발자로 하려금 근본적인 원인을 파악할 수 있도록 충분한 상태 정보와 스냅샷을 제공합니다.

하드웨어에서 소프트웨어까지 하나의 집단 또는 회사가 만드는 임베딩 시스템에서는 모든 버그는 근본 원인에 속하는 엔지니어의 책임입니다.<br>
공격적인 프로그래밍은 몇 주에 걸쳐서 발생할 수 있는 버그나, 자의적으로 재생산할 수 없는 버그의 경우 해결할 수 있는 실마리를 제공하는 유용한 방법입니다.

공격적 프로그래밍은 소프트웨어 내부에서 다양한 방식으로 적용될 수 있고, 흔한 방법으로는 [assertions](https://interrupt.memfault.com/blog/asserts-in-embedded-systems) 라이브러리 또는 개발자에 의한 에러와 시스템 상태에 대응할 수 있는 엔지니어링 실력이 있습니다.

이론적으로 발생 가능한 상황을 통해 어떤 방식으로 공격적 프로그래밍을 구현할지 간단하게 다뤄봅시다.

만약 당신의 임베디드 시스템이...

* **성능 이슈를 겪고 있을 때** - 예를 들어 GUI 프리징 또는 외부 하드웨어 입력으로부터 지연이 있는 경우,<br>
[watchdogs](https://interrupt.memfault.com/blog/firmware-watchdog-best-practices) 또는 타이머와 `assertions`를 이용해서 시스템이 멈추는 순간 무엇이 CPU 점유율이 잡아먹는지 찾을 수 있습니다.

* **메모리 이슈를 겪고 있을 때** - 스택오버 플로우, 힙 메모리 고갈, 프레그멘테이션 에러(exsessive fragmentation), 등 다양한 이유로 인한 시스템 충돌이 일어난 경우 개발자가 해결방법을 찾을 수 있는 캡처를 제공해서 어디서부터 문제가 일어 났는지 해결할 수 있습니다.<br>
`malloc()`과 같이 상위의 추상적인 함수가 시스템의 에러를 일으키는 마지막 순간일 확률은 낮습니다. 함수가 실행되는 중간 과정에서 일어날 확률이 높습니다.

* **락 이슈(Locking issue)를 겪고 있을 때** - `mutex_lock`, `queue_put`과 같은 RTOS 함수에 낮은 타임아웃(5초)을 세팅합니다.<br>
낮은 타임아웃은 지정된 시간 이내에 함수가 실행되지 않으면 시스템이 크래시를 하게끔 만들 것이고, 개발자로 하여금 근본 원인을 찾는데 도움을 줄겁니다.<br>
원인을 찾아서 반복해서 같은 코드를 보는 것을 줄일 수 있고, watchdog이 [알아서 정리](https://interrupt.memfault.com/blog/firmware-watchdog-best-practices)할 수 있도록 기대할 수 있습니다

위에서 다룬 세 가지 경우에 대한 간단한 대처방법입니다. 여러분이 직접 다른 방법을 통해서 해결 할수도 있고요.<br>
예시를 보면서 공격적 프로그래밍의 의미를 파악할 수 있었길 바랍니다.

<br>

### 공격적 프로그래밍의 장점

공격적 프로그래밍에 대해 알아보면서 왜 여러분의 코드와 펌웨어를 `assert`, `timers`, watchdogs, 그리고 `faults`로 덕지덕지 조작해야하는지 의문을 가질 수 있습니다.<br>
임베딩 시스템에 크래시가 발생하는 경우 단순히 스레드가 멈추는 것이아니라 임베딩 시스템에 의존하는 **시스템 전체**에 문제가 발생할 수 있기 때문입니다.

방어적/공격적 프로그래밍은 양날의 검과 같습니다.

한 측면으로는, 디바이스(앱)에서 예상하지 못한 이슈를 직면했을 경우 이슈를 직접 알리지 않고 그대로 시스템이 돌아갈 수 있게끔 방치할 수 있습니다.<br>
어떤 문제가 발생했는지 정의하지 않고, 어떤 추가적인 문제가 발생할지 전혀 모르는 상태에서 말이죠.

힙 메모리가 부족한 상황일 수도, 큐잉(queueing)이 제대로 일어나지 않았거나, 스레드에 데드락이 생겨서 자동 복구 매커니즘이 구축되어 있지 않을 수도 있죠.<br>
어떤 하드웨어 디바이스는 문제 상황이 발생했을 때 강제로 끌 수 있는 파워 버튼도 없을 수도 있습니다.<br>
문제가 발생해도 시스템으로 하여금 계속 돌아가게끔 만들 수 있습니다(방어적 프로그래밍).

다른 측면으로는 예상 못한 상황에서 디바이스는 복구 불가능한 상태에 놓여지고 반드시 리셋이 필요한 경우도 있을 수 있습니다.<br>
메모리 누수로 인한 힙 메모리가 부족한 경우, 이 조차 복수할 수 있는 메모리가 남아있지 않을 수도 있습니다.

스레드가 데드락에 놓여있을 경우도 복구할 수 없을 겁니다.<br>
정의되어 있지 않은 상태에 놓인 펌웨어는 심각한 보안 문제로부터 노출될 수도 있습니다.<br>
문제가 발생했음에도 불구하고 외부적으로 시스템에 개입하지 않으면 불안정한 상태로 놓여있을 수 있습니다(공격적 프로그래밍).

여러분의 펌웨어가 예상하지 않은 상태에 놓인채로 작동하는 것을 방지하기 위해서, 버그가 일어난 시점에 assert를 발동하고,<br>
falut를 정확한 순간에 던지는 것이 개발자로 하여금 근본 원인을 찾고 해결하는데 도움을 줍니다.<br>

디버깅을 하면서 버그가 일어난 즉시 알려주면(공격적 프로그래밍) 아래 서술한 내용의 장점을 가져갈 수 있습니다.

* **빠른 버그 수정** - 시스템이 정지하거나, 코어 덤프(core dump)의 캡처본이 떠진 경우, 개발자는 바로 백트레이스(backtrace), 레지스터, 함수 인자에 접근할 수 있습니다.<br>
버그가 발생한 당시의 정보를 보면서 더 빠르게 수정할 수 있겠죠?

* **더 빠른 개발** - 새로운 코드를 작성하고 다른 모듈에 이식하면 버그를 해결하기 까다로울 수 있습니다.<br>
공격적 프로그래밍을 통해서 API 스펙과 다른 다르게 행동할 경우 빠르게 알려줄 수 있고, 즉시 해결할 수 있습니다.<br>
나중에 기억 나지도 않는 에러 메세지와 이해할수 없는 에러를 보면서 추적하는 것보단 더 나겠죠?

* **빠른 인지** - 프로그램으로 하여금 강제로 종료, 중단하게끔 해서 프로그래머에게 버그가 있음을 인지시킬 수 있습니다.<br>
리셋, 재시작을 강제로 하게끔해서 프로그래머가 버그가 얼마나 자주, 반복적으로 일어나는지 인지시킬 수 있습니다.

* **빠른 복구** - 데드락 상태와 비슷하게 다바이스가 동작을 멈추는 경우, 리셋을 하게끔 알려줄 수 있습니다.<br>
디바이스를 리셋하면서 정상적으로 작동하는 상태로 만들 수 있고, 임베딩 다이바이스는 대부분 빠르게 리셋할 수 있으니 오랜 시간이 소요되지도 않습니다.
  

## 공격적 프로그래밍 실습

### 함수의 인자 평가하기
    
### 리소스 고갈 대처하기
    
### 소프트웨어 정지와 데드락
    
### Use After Free Bugs
    
### State Transition Errors
    
### 프로그래머에 의한 컴파일 타임 에러
