# Defensive Programming - Friend or Foe?

- Tyler Hoffman

원본 링크 : [Defensive Programming - Friend or Foe?](https://interrupt.memfault.com/blog/defensive-and-offensive-programming)

## 목차

* 번역

## 번역

방어적 프로그래밍 - 친구일까 적일까?

임베딩 개발(특히 C언에서)을 하면서 제일 최악의 경우 중 하나는 함수를 실행하고 그 반환값으로 아무런 정보없이 `-1` 또는 `unknown_error`를 받는 것입니다.<br>
이 에러가 어디서, 언제 일어났는지 말도 없이 단지 에러가 났다고만 말하는 겁니다!

임베딩 개발자이라면 한번쯤은 새로운 보드, 드라이버, 모듈, 그리고 앱까지 이 지경까지 도달했는지 헤맸을 경험이 있을겁니다.<br>
기저에 깔린 이슈의 원인을 찾는 것은 마치 양파를 까는 것과 같습니다.<br>
디버깅을 하면서 껍질 하나하나 까면서 이게 뭔지, 왜 이러는 건지 웃음기는 사라지고 점점 눈물과 짜증만 치밀어 오르죠.<br>

이런 이슈들은 대부분 프레임워크를 사용하는 개발자로 인해 발생한 에러의 결과물입니다.<br>
함수를 순서대로 또는 제 때 호출하지 않거나, 옳바르지 않은 인자가 주어졌을 경우 일어나죠.<br>
또는 메모리가 부족하거나 데드락(dead-lock) 상태인 경우 시스템 자체에 문제가 있어 일어날 수도 있죠.

펌웨어는 이슈가 있고, 또 그 이슈가 어떤 이슈인지를 알지만, 이슈를 해결하는데 도움은 주지 않습니다.<br>
**방어적 프로그래밍**(Defensive Programming)을 했기 때문에, 의도하지 않은  동작이 발생해도 돌아게끔 했기 때문입니다.

저는 문제가 발생했음에도 조용히 넘어가는 것보단 차라리 펌웨어 크래시(crash)가 일어나거나, 유용한 에러를 출력해서 정확히 어떤 이슈가 어디서 일어났는지 알려주는 것을 선호합니다.<br>
에러가 났으면 적극적으로 알리고, 더 나아가서 아예 펌웨어가 크래시가 나게끔 냅두는 **공격적 프로그래밍**(Offensive Programming)에 대해서 설명해드리겠습니다.

이 글에서는 크게 4가지 부분으로 구성되어 있습니다

* 방어적 프로그래밍과 공격적 프로그래밍이란 무엇인가

* 방어적 프로그래밍의 단점은 무엇인가

* 개발자가 ~~~~~ 프로그래밍을 사용할 때 어떤점을 유의해야하는가 -> 방어적인 프로그래밍

how developers should think about using them within embedded systems

* 공격적 프로그래밍의 기술이 어떻게 개발자에게 런타임 도중 버그를 노출시키고 알려줄 수 있는가

방어적, 공격적 프로그래밍에 대해서 알게되면 1000시간 중에 한번 나올까하는 희귀한 버그를 쉽게 추하고, 근본 원인을 쉽게 찾을 수 있게 해줄겁니다.<br>
무엇보다 엔드 유저를 기쁘게 할 수 있으며, 여러분의 정신줄 또한 붙잡게 해줄 것입니다.

## 목차

* 방어적 프로그래밍

    * 방어적 프로그래밍의 단점
    
* 공격적 프로그래밍

    * 공격적 프로그래밍의 장점
    
* 공격적 프로그래밍 실습

    * 함수의 인자 평가하기
    
    * 리소스 고갈 대처하기
    
    * 소프트웨어 정지와 데드락
    
    * Use After Free Bugs
    
    * State Transition Errors
    
    * 프로그래머에 의한 컴파일 타임 에러
    
* 외부 입력 및 상황과 애플리케이션 코드 핸들링

* 모범 예시

    * Don't Assert on Boot Sequences
    
    * Playing Offense Internally
    
    * Playing Offense in Production Builds

* 결론

<br>

## 방어적 프로그래밍 

방어적 프로그래밍은 예상에 없었던 이슈가 발생하거나 발생하는 도중에도 소프트웨어가 계속해서 잘 실행될 수 있도록 하는 프로그래밍 설계 방식입니다.<br>
간단한 예시로는 `malloc()`을 호출한 뒤 `NULL`을 반환했는지 확인하고, `NULL`을 반환했을 경우 애플리케이션이 계속해서 작동할 수 있도록 처리하는 것이죠.

```c
void do_something(void) {
  uint8_t *buf = malloc(128);
  if (buf == NULL) {
    // handle this gracefully!
  }
}
```

방어적 프로그래밍은 듣기만하면 좋습니다, 실제로 좋기도 하고요!<br>
우리가 작성하는 펌웨어는 예상에 없던 상황으로 인해서 재앙 수준으로 무너져선 안됩니다.

방어적 프로그래밍은 하드웨어, 외부 라이브러리, 제어할 수 없는 입력과 상호작용하는 순간에서 능력을 발휘합니다.<br>
하드웨어는 결함을 가질수 있고 다른 환경에서 다르게 작동할 수 있고, *무거운* 라이브러리는 버그투성이고, 외부입력은 입력하라는 것과 달리 다른 것을 입력하곤 합니다.

대부분에 해당되는 일이지만, 방어적 프로그래밍은 단점보다 장점이 더 부각되면서 남용될 수 있습니다.<br>
방어적 프로그래밍이 된 모듈 위에 모듈이 쌓이게되면 발생하는 예외와 버그들은 사라지고, 무시됩니다. 추적조차 할 수 없겠죠.

### 방어적 프로그래밍의 단점

방어적 프로그래밍을 사용하는 주요 대상은 여러분이 작성하는 펌웨어의 외부로 노출되는 인터페이스입니다.<br>
외부로 노출되는 인터페이스에는 간단하지만, 든든한 벽같은 방어적 프로그래밍이 있어야합니다.<br>
반대로 외부에서 접근할 수 없는 내부 코드는 더욱 공격적으로 예외 상황 또는 에러가 발생할 경우 assert 하는 환경이 조성되어야합니다.

<!-- https://interrupt.memfault.com/blog/img/defensive-and-offensive-programming/internal-software.png -->

<!-- If code paths originate from or pass through the red zones, then defensive programming is a good approach. -->

제어를 할 수 **없는** 외부로부터 입력에 대해서는 관대하게,<br>
제어를 할 수 **있는** 내부에서는 엄격하게 관리해야하는 것이죠.

예를 들어, 문자열과 길이를 받고 해싱(hash)을 해 주는 함수 `hash32_djb2`가 있다고 가정합시다.<br>
이 함수는 외부로부터 직접적으로 사용되지 않고 내부 개발자만 사용합니다.

```c
uint32_t hash32_djb2(const char *str, int len){
  if (str == NULL) {
    // Invalid arguemnt
    return 0;
  }
  ...
}
```

이런 코드는 스스로 해치는 코드와 다름 없습니다. 

예외 상황으로 문자열 참조 인자 `*str`에 `NULL`이 주어졌음에도 불구하고, 예상된 반환 타입, `uint32_t`인 '0'을 반환했기 때문이죠.

이와 같이 내부적으로 사용되는 코드(역주 : 외부에 노출되지 않는 private property)는 개발자 자체의 버그이고, **즉시** 고쳐야합니다.<br>
개발자가 스스로 발생한 버그를 눈 앞에서 보고, 고치지도 않고 아무렇지 않게 '예외처리'를 한다는 것이 말이 됩니까?

이와 같이 간단히 본 예외처리를 단순히 비정상적인 값이라고 알려주는 `NULL`, `-1`, `Empty String`, 등을 반환하는 것과 반대로<br>
적극적으로 개발자의 코드에서 에러가 발생하면, 코드가 자체적으로 처리하는 것이 아닌, 개발자게에게 직접 에러가 발생했을을 알리는,<br>
**적극적**으로 알리는 프로그래밍 방식이 "**공격적 프로그래밍**"(Offensive Programming) 입니다.

