# Defensive Programming - Friend or Foe?

by Tyler Hoffman

원본 링크 : [Defensive Programming - Friend or Foe?](https://interrupt.memfault.com/blog/defensive-and-offensive-programming)

# 방어적 프로그래밍 - 친구일까 적일까?

임베딩 개발(특히 C언에서)을 하면서 제일 최악의 경우 중 하나는 함수를 실행하고 그 반환값으로 아무런 정보없이 `-1` 또는 `unknown_error`를 받는 것입니다.<br>
이 에러가 어디서, 언제 일어났는지 말도 없이 단지 에러가 났다고만 말하는 겁니다!

임베딩 개발자이라면 한번쯤은 새로운 보드, 드라이버, 모듈, 그리고 앱까지 이 지경까지 도달했는지 헤맸을 경험이 있을겁니다.<br>
근본적인 원인을 찾아 모듈을 하나씩 뒤져보는 것은 마치 양파를 까는 것과 같습니다.<br>
디버깅을 하면서 이게 뭔지, 왜 이러는 건지 웃음은 사라지고 점점 눈물과 짜증만 치밀어 오르죠.<br>

이런 이슈들은 대부분 프레임워크를 사용하는 개발자로 인해 발생한 에러의 결과물입니다.<br>
함수를 순서대로 또는 제때 호출하지 않거나, 형식에 맞지 않는 인자가 주어지는 경우 또는 메모리가 부족하거나 데드락(dead-lock) 상태인 경우 시스템 자체에 문제가 있어 일어날 수도 있죠.

펌웨어의 입장에선 문제가 발생했고, 어떤 문제인지 알지만, 문제를 해결하는데 도움은 주지 않습니다.<br>
**방어적 프로그래밍**(Defensive Programming)을 했기 때문에, 문제가 발생해도 돌아게끔 했기 때문입니다.

저는 문제가 발생했음에도 조용히 넘어가는 것보단 차라리 펌웨어 크래시(crash)가 일어나거나, 유의미한 에러와 트레이스 백(traceback)을 출력해서 정확히 어디서, 어떤 이슈가 일어났는지 알려주는 것을 선호합니다.<br>
에러가 났으면 적극적으로 알리고,  아예 펌웨어가 정지하도록 설계한 **공격적 프로그래밍**(Offensive Programming)에 대해서 설명해드리겠습니다.

이 글에서는 크게 네 가지 내용으로 구성되어 있습니다

* **방어적 프로그래밍과 공격적 프로그래밍이란 무엇인가**

* **방어적 프로그래밍의 단점은 무엇인가**

* **임베딩에서 공격적 프로그래밍을 사용할 때 어떤점을 유의해야하는가**

* **공격적 프로그래밍이 어떻게 개발자에게 런타임 도중 버그를 노출시키고 알려줄 수 있는가**

방어적/공격적 프로그래밍에 대해서 알게되면 보지 못한 버그를 재현하는데 고생을 덜 수 있으며, 생산성 증대에 큰 도움이 될 것입니다.

## 목차

* 방어적 프로그래밍

    * 방어적 프로그래밍의 단점
    
* 공격적 프로그래밍

    * 공격적 프로그래밍의 장점
    
* 공격적 프로그래밍 실습

    * 함수의 인자 평가하기
    
    * 리소스 고갈 대처하기
    
    * 소프트웨어 정지와 데드락
    
    * 메모리 해제 후 재사용 버그
    
    * 상태 변이 에러
    
    * 프로그래머에 의한 컴파일 타임 에러
    
* 외부 입력 및 상황과 애플리케이션 코드 핸들링

* 모범 예시

    * Don't Assert on Boot Sequences
    
    * Playing Offense Internally
    
    * Playing Offense in Production Builds

* 결론

<br>

## 방어적 프로그래밍 

방어적 프로그래밍은 예상에 없던 문제가 발생하거나, 발생하는 도중에도 소프트웨어가 계속해서 잘 실행될 수 있도록 하는 프로그래밍 설계 방식입니다.

아래 예시 코드는 `malloc()`을 호출한 뒤 `NULL`을 반환했는지 확인하고, `NULL`을 반환했을 경우 애플리케이션이 계속해서 작동할 수 있도록 처리합니다.

```c
void do_something(void) {
  uint8_t *buf = malloc(128);
  if (buf == NULL) {
    // 알아서 잘 처리하기!
  }
}
```

방어적 프로그래밍은 듣기만하면 좋습니다, 실제로 좋기도 하고요!<br>

외부로 유통된 펌웨어는 예상하지 못한 문제로 인한 재앙으로 무너져선 안됩니다.

방어적 프로그래밍은 개발자가 **제어할 수 없는 상황**인 하드웨어, 외부 라이브러리, 외부 입력과 상호작용하는 순간에서 능력을 발휘합니다.<br>
하드웨어는 결함을 가질수 있고 다른 환경에서 다르게 작동할 수 있고, *무거운* 라이브러리는 버그투성이고, 외부 입력으로부터 이상한 것만 들어옵니다.

방어적 프로그래밍은 예외 상황으로 인해 발생하는 문제로부터 안전해질 수 있다는 인식으로 남용될 가능성이 높습니다.

방어적 프로그램이 쌓이고 쌓이면 발생하는 예외와 버그들은 조치를 취하지 못하면서, 더 추상화된 API 단계에서 접하는 에러는 고칠 가능성 조차 없어지게 됩니다.

문제가 발생해도 사라지고, 무시됩니다. 추적조차 할 수 없겠죠.

<br>

### 방어적 프로그래밍의 단점

방어적 프로그래밍을 사용하는 주요 대상은 펌웨어 외부로 노출되는 인터페이스입니다.<br>
**외부에 노출되는 인터페이스**는 간단하지만, 든든한 벽 같은 방어적 프로그래밍이 되어 있어야합니다.<br>
반대로 외부에서 접근할 수 없는 **내부 코드**는 더욱 공격적으로 예외 상황 또는 에러가 발생할 경우 assert 하는 환경이 조성되어야합니다.

<!-- https://interrupt.memfault.com/blog/img/defensive-and-offensive-programming/internal-software.png -->

<!-- 사진 주석 : If code paths originate from or pass through the red zones, then defensive programming is a good approach. -->

제어를 할 수 **없는** 외부로부터 입력에 대해서는 관대하게,<br>
제어를 할 수 **있는** 내부에서는 엄격하게 관리해야하는 것이죠.

예를 들어, 문자열과 길이를 받고 해싱(hash)을 해 주는 함수 `hash32_djb2`가 있다고 가정합시다.<br>
이 함수는 외부에서 접근할 수 없는 private한 코드 입니다.

```c
uint32_t hash32_djb2(const char *str, int len){
  if (str == NULL) {
    // Invalid arguemnt
    return 0;
  }
  ...
}
```

이런 코드는 스스로 해치는 코드와 다름 없습니다. 

예외 상황으로 문자열 참조 인자 `*str`에 `NULL`이 주어졌음에도 불구하고, 예상된 반환 타입, `uint32_t`인 '0'을 반환했기 때문이죠.

`hash32_djb2()` 함수를 사용하는 모든 코드는 '0'을 반환 받아도 정상적으로 코드가 실행되었다고 인식할 수 있습니다.

내부적으로 사용되는 코드(역주 : 외부에 노출되지 않는 private property)는 개발자 자체의 버그이고, **즉시** 고쳐야합니다.<br>
개발자가 스스로 발생한 버그를 눈 앞에서 보고, 고치지도 않고 아무렇지 않게 '예외처리'를 한다는 것이 말이 됩니까?

문제가 발생했다고  반환값으로  `NULL`, `-1`, `(Empty String)`, 등을 반환해서 알려주는 것과 반대로<br>
문제가 발생하면 코드 자체적으로 처리하는 것이 아닌, 프로그램을 중단시켜 개발자에게 문제가 발생했을을 알리는,<br>
**적극적**으로 알리는 프로그래밍 방식이 "**공격적 프로그래밍**"(Offensive Programming) 입니다.

## 공격적 프로그래밍

공격적 프로그래밍이라는 단어를 봤을 때 방어적 프로그래밍과 정반대의 개념처럼 보일 수 있지만, 방어적 프로그래밍을 확장한 개념에 가깝습니다.
지금 당장 마음에 와닿지 않더라도 결국 방어적, 공격적 프로그래밍은 같은 원초적으로 목표를 두고 있다는 것을 느낄 수 있을 겁니다.

> Attack is the Best Defence - 선즉제인(先則制人)

방어적 프로그래밍 목차에서 본 예시에서, 공격적 프로그래밍은 `malloc()` 함수가 단순히 실패할 수 있다는 것을 그대로 묵인하지 않습니다.<br>
`malloc()` 함수가 메모리 확보에 실패하면 곧 바로 `assert`를 한 뒤 개발자로 하려금 근본적인 원인을 파악할 수 있도록 충분한 상태 정보와 스냅샷을 제공합니다.

하드웨어에서 소프트웨어까지 하나의 집단 또는 회사가 만드는 임베딩 시스템에서는 모든 버그는 근본 원인에 속하는 엔지니어의 책임입니다.<br>
공격적인 프로그래밍은 몇 주에 걸쳐서 발생할 수 있는 버그나, 자의적으로 재생산할 수 없는 버그의 경우 해결할 수 있는 실마리를 제공하는 유용한 방법입니다.

공격적 프로그래밍은 소프트웨어 내부에서 다양한 방식으로 적용될 수 있고, 흔한 방법으로는 [assertions](https://interrupt.memfault.com/blog/asserts-in-embedded-systems) 라이브러리 또는 개발자에 의한 에러와 시스템 상태에 대응할 수 있는 엔지니어링 실력이 있습니다.

이론적으로 발생 가능한 상황을 통해 어떤 방식으로 공격적 프로그래밍을 구현할지 간단하게 다뤄봅시다.

만약 당신의 임베디드 시스템이...

* **성능 이슈를 겪고 있을 때** - 예를 들어 GUI 프리징 또는 외부 하드웨어 입력으로부터 지연이 있는 경우,<br>
[watchdogs](https://interrupt.memfault.com/blog/firmware-watchdog-best-practices) 또는 타이머와 `assertions`를 이용해서 시스템이 멈추는 순간 무엇이 CPU 점유율이 잡아먹는지 찾을 수 있습니다.

* **메모리 이슈를 겪고 있을 때** - 스택오버 플로우, 힙 메모리 고갈, 프레그멘테이션 에러(exsessive fragmentation), 등 다양한 이유로 인한 시스템 충돌이 일어난 경우 개발자가 해결방법을 찾을 수 있는 캡처를 제공해서 어디서부터 문제가 일어 났는지 해결할 수 있습니다.<br>
`malloc()`과 같이 상위의 추상적인 함수가 시스템의 에러를 일으키는 마지막 순간일 확률은 낮습니다. 함수가 실행되는 중간 과정에서 일어날 확률이 높습니다.

* **락 이슈(Locking issue)를 겪고 있을 때** - `mutex_lock`, `queue_put`과 같은 RTOS 함수에 낮은 타임아웃(5초)을 세팅합니다.<br>
낮은 타임아웃은 지정된 시간 이내에 함수가 실행되지 않으면 시스템이 크래시를 하게끔 만들 것이고, 개발자로 하여금 근본 원인을 찾는데 도움을 줄겁니다.<br>
원인을 찾아서 반복해서 같은 코드를 보는 것을 줄일 수 있고, watchdog이 [알아서 정리](https://interrupt.memfault.com/blog/firmware-watchdog-best-practices)할 수 있도록 기대할 수 있습니다

위에서 다룬 세 가지 경우에 대한 간단한 대처방법입니다. 여러분이 직접 다른 방법을 통해서 해결 할수도 있고요.<br>
예시를 보면서 공격적 프로그래밍의 의미를 파악할 수 있었길 바랍니다.

<br>

### 공격적 프로그래밍의 장점

공격적 프로그래밍에 대해 알아보면서 왜 여러분의 코드와 펌웨어를 `assert`, `timers`, watchdogs, 그리고 `faults`로 덕지덕지 조작해야하는지 의문을 가질 수 있습니다.<br>
임베딩 시스템에 크래시가 발생하는 경우 단순히 스레드가 멈추는 것이아니라 임베딩 시스템에 의존하는 **시스템 전체**에 문제가 발생할 수 있기 때문입니다.

방어적/공격적 프로그래밍은 양날의 검과 같습니다.

한 측면으로는, 디바이스(앱)에서 예상하지 못한 이슈를 직면했을 경우 이슈를 직접 알리지 않고 그대로 시스템이 돌아갈 수 있게끔 방치할 수 있습니다.<br>
어떤 문제가 발생했는지 정의하지 않고, 어떤 추가적인 문제가 발생할지 전혀 모르는 상태에서 말이죠.

힙 메모리가 부족한 상황일 수도, 큐잉(queueing)이 제대로 일어나지 않았거나, 스레드에 데드락이 생겨서 자동 복구 매커니즘이 구축되어 있지 않을 수도 있죠.<br>
어떤 하드웨어 디바이스는 문제 상황이 발생했을 때 강제로 끌 수 있는 파워 버튼도 없을 수도 있습니다.<br>
문제가 발생해도 시스템으로 하여금 계속 돌아가게끔 만들 수 있습니다(방어적 프로그래밍).

다른 측면으로는 예상 못한 상황에서 디바이스는 복구 불가능한 상태에 놓여지고 반드시 리셋이 필요한 경우도 있을 수 있습니다.<br>
메모리 누수로 인한 힙 메모리가 부족한 경우, 이 조차 복수할 수 있는 메모리가 남아있지 않을 수도 있습니다.

스레드가 데드락에 놓여있을 경우도 복구할 수 없을 겁니다.<br>
정의되어 있지 않은 상태에 놓인 펌웨어는 심각한 보안 문제로부터 노출될 수도 있습니다.<br>
문제가 발생했음에도 불구하고 외부적으로 시스템에 개입하지 않으면 불안정한 상태로 놓여있을 수 있습니다(공격적 프로그래밍).

여러분의 펌웨어가 예상하지 않은 상태에 놓인채로 작동하는 것을 방지하기 위해서, 버그가 일어난 시점에 assert를 발동하고,<br>
falut를 정확한 순간에 던지는 것이 개발자로 하여금 근본 원인을 찾고 해결하는데 도움을 줍니다.<br>

디버깅을 하면서 버그가 일어난 즉시 알려주면(공격적 프로그래밍) 아래 서술한 내용의 장점을 가져갈 수 있습니다.

* **빠른 버그 수정** - 시스템이 정지하거나, 코어 덤프(core dump)의 캡처본이 떠진 경우, 개발자는 바로 백트레이스(backtrace), 레지스터, 함수 인자에 접근할 수 있습니다.<br>
버그가 발생한 당시의 정보를 보면서 더 빠르게 수정할 수 있겠죠?

* **더 빠른 개발** - 새로운 코드를 작성하고 다른 모듈에 이식하면 버그를 해결하기 까다로울 수 있습니다.<br>
공격적 프로그래밍을 통해서 API 스펙과 다른 다르게 행동할 경우 빠르게 알려줄 수 있고, 즉시 해결할 수 있습니다.<br>
나중에 기억 나지도 않는 에러 메세지와 이해할수 없는 에러를 보면서 추적하는 것보단 더 나겠죠?

* **빠른 인지** - 프로그램으로 하여금 강제로 종료, 중단하게끔 해서 프로그래머에게 버그가 있음을 인지시킬 수 있습니다.<br>
리셋, 재시작을 강제로 하게끔해서 프로그래머가 버그가 얼마나 자주, 반복적으로 일어나는지 인지시킬 수 있습니다.

* **빠른 복구** - 데드락 상태와 비슷하게 다바이스가 동작을 멈추는 경우, 리셋을 하게끔 알려줄 수 있습니다.<br>
디바이스를 리셋하면서 정상적으로 작동하는 상태로 만들 수 있고, 임베딩 다이바이스는 대부분 빠르게 리셋할 수 있으니 오랜 시간이 소요되지도 않습니다.
  

## 공격적 프로그래밍 실습

구체적인 예시를 통해 공격적인 프로그래밍에 대해 알아봅시다

### 함수의 인자 평가하기

API를 사용하는 개발자가 함수에 적절하지 않은 이자를 전달하는 경우, 애플리케이션이 고치라고 당장 알리세요.

함수가 적절하지 않은 인자를 받았을 떄 `-1`을 반환값으로 돌려주는 것만큼 최악의 함수는 없습니다.

```c
void device_set_name(char *name, size_t name_len) {
  ASSERT(name && name_len <= 16);
  // ...
}
```

예시처럼 바로 `ASSERT`를 사용하지 않는 유일한 경우로는 제가 속해있는 조직 외부 사람들이 사용하는 라이브러리를 제작할 때 입니다.<br>
이런 경우, 인자가 유효한지를 판단하는 `ASSERT`를 사용자가 직접 결정 할 수 있도록 만듭니다.

예시로 RTOS 함수의 `configASSERT` 옵션이 있습니다.

### 리소스 고갈 대처하기

임베딩 시스템에서 동적 메모리를 사용하는 것이 탐탁지 않지만, 정적 메모리만으로 부족한 복잡한 시스템을 작동시키기 위해선 사용하게됩니다.<br>
동적 메모리를 사용해도 가끔 메모리가 부족해지는 상황이 발생하곤 합니다.<br>
메모리가 얼마 남지 않았을 때, 시스템은 기존에 점유하고 있는 메모리와 데이터 소모성 작업을 관리해야합니다.

그러나 펌웨어의 동적 메모리 풀이 모두 점유된 상황이  발생한다면 **왜**, **언제**, 어디서 발생했는지 찾아내야합니다.<br>
메모리 릭(leak)일 수도 있고, 힙 메모리에 잘못 할당되어 있을 수도 있습니다.<br>
시스템이 스스로 복구될 수 있기 때문에 메모리 고갈 문제는 상용화 단계에서 당장 크게 눈에 띄지 않을수도 있지만,<br>
개발이나 테스트 단계일 때는 근본 원인을 찾아서 해결해야합니다.

우선 `malloc()` 함수가 제대로 작동했는지 부터 점검할 필요가 있습니다

```c
void *malloc_assert(size_t n){
  void *p = malloc(n)
  ASSERT(p);
  return p;
  // ....
}
```

반드시 메모리가 확보되어야 하는 버퍼, 리퀘스트(request), 초기화, 등에서 `malloc()`이 호출되는 구간에서는 반드시 실패해선 안됩니다.<br>

RTOS 기반 시스템에서 자주 언급되는 문제로는 큐(queue)에 쌓인 작업이 제때 처리되지 않아서 큐에 더 이상 추가(put)할 수 없는 상황이 있습니다.<br>

이런 문제가 시스템 전체를 정지시키거나, 셧 다운되는 수준까지 이르지 않지만<br>
반드시 처리해야하는 이벤트가 무시되는 경우 디바이스 작동에 큰 문제가 발생할 가능성이 있습니다.

이런 문제는 반드시 해결해야합니다.

큐에 작업을 추가하는 함수에 작업이 정상적으로 큐에 등록이 되었는지 `ASSERT()`를 이용해 확인할 수 있습니다.

```c
void critical_event(void){
  //...
  const bool success = xQueueSend(q, &item, 1000 /* 지연시간 */)
  ASSERT(success);
  // ...
}
```

큐가 꽉차는 문제를 디버깅할 때 [Python GDB Script](https://interrupt.memfault.com/blog/automate-debugging-with-gdb-python-api)를 이용해 큐에 있는 컨텐츠를 덤프하는 것을 권장드립니다.<br>

```
(gdb) queue_print s_event_queue
Queue Status: 10/10 events in queue (FULL!)
0: Addr: 0x200070c0, event: BLE_PACKET
1: Addr: 0x200070a8, event: TICK_EVENT
2: Addr: 0x20007088, event: BLE_PACKET
3: Addr: 0x20007070, event: BLE_PACKET
4: Addr: 0x20007050, event: BLE_PACKET
5: Addr: 0x20007038, event: BLE_PACKET
6: Addr: 0x20007018, event: BLE_PACKET
7: Addr: 0x20007000, event: BLE_PACKET
8: Addr: 0x20006fe0, event: BLE_PACKET
9: Addr: 0x20006fc8, event: BLE_PACKET
```

이 예시에서는 큐에 패킷으로 가득찼고, 패킷이 제 속도로 처리되지 않은 것을 확인할 수 있습니다.<br>
어떤 문제가 발생했는지 알 수 있으니 해결책을 찾을 수 있겠죠?

### 소프트웨어 정지와 데드락

임베디드 디바이스는 한순간의 지연이나 정지현상 없이 빠르게 사용자 input과 패킷에 대해 반응할 수 있어야합니다.

이전 프로젝트에서 느린 처리 속도로 인해서 시스템이 2-3초간 정지되는 것을 수 없이 봤는데요.<br>
이런 일이 매번 일어날때마다 사용자 경험을 해치는 것은 물론이고, timeout인해 다른 시스템에 문제가 발생해 고생했습니다.

최악의 부분은 이런 문제들이 개발자가 알아차리기까지 시간이 오래걸린다는 점입니다.

펌웨어를 릴리스하기 전에 [task watchdogs](https://interrupt.memfault.com/blog/firmware-watchdog-best-practices#adding-a-task-watchdog)를 이용해 좀더 가혹한 조건으로 테스트를 진행하면 미리 문제를 잡아낼 수 있습니다.<br>
timeout을 이용해 처리 시간이 길거라고 예상되는 작업에 `ASSERT`를 하는 방법이 있습니다.

mutex가 **시간 내에** 성공적으로 lock되는 것을 assert 하기 위해 RTOS call에 timeout을 설정하면 됩니다.

```c
void timing_sensitive_task(void) {
  const bool success = mutex_lock(&s_mutex, 1000 /* 1초 */ );
  ASSERT(success);
  {
    // ...
    
  }
}
```

[task watchdogs](https://interrupt.memfault.com/blog/firmware-watchdog-best-practices#adding-a-task-watchdog)를 정지 현상을 발견하도록 설정했다면 지연시간을 무한으로 시간을 잡으면 됩니다.

```c
void timing_sensitive_task(void) {
  // Task watchdog이 정지를 assert 할겁니다
  const bool success = mutex_lock(&s_mutex, INFINITY);
}
```

제품을 릴리스하기 전에는 코드를 *방어적*으로 만들는 timeout을 없애거나 늘려서, 최악 직전의 조건에서는 동작하게끔 만드시면 됩니다. 

### 메모리 해제 후 재사용 버그

원제 : Use After free() Bugs
  
`malloc()`으로 할당되고 나중에 `free()`된 버퍼 메모리는 소프트웨어에 의해 **절대** 다시 쓰여선 안됩니다.

하지만 이런 일은 종종 일어나죠.

이런 현상은 "메모리 해제 후 재사용(Use After Free)" 버그로 불립니다.<br>
이 버그가 발생해도 아무일도 안생길 확률은 매우 높습니다.

그러나 가끔, 메모리 오염(Memory Corruption) 발생해 기괴한 모습으로 나타날 수 있습니다.<br>
디버깅 난이도가 매우 높아서 한번 잘못 발생하면 고생하실 겁니다.

> 메모리 오염 문제로 인해 고생하고 있으면
> 이전 글의 [메모리 오염 디버깅](https://interrupt.memfault.com/blog/cortex-m-watchpoints#memory-corruption) 항목을 읽는 것을 권장드립니다.

'메모리 해제 후 재사용' 버그를 방지하는 방법으로 메모리를 해제하기 전에 메모리에 *접근하면 안되는 메모리 주소*로 다시 덮어 쓰는 것입니다.

'메모리 해제 후 재사용' 버그가 발생하고 (재수 없게) 문제가 발생했을 때, *접근해선 안되는 메모리 주소*를 읽으면 코어 덤프를 만들게끔 유도 하는 것입니다.

여기서 포인트는 *접근해선 안되는 메모리 주소*를 나중에 내가 **알아볼 수 있는 주소**로 정한뒤(상수) 디버깅 할 때 유효하지 않은 메모리 접근이 발생했을 떄<br>
내가 지정한 주소가 코어 덤프(core dump)에 나와 있으면 '아 메모리 버그가 일어난거구나'하고 넘어갈 수 있는겁니다.

```c
void my_free(void *p){
  const size_t num_bytes = prv_get_size(p);
  // 바이트에 내가 알아볼 수 있는 주소로 채워 넣습니다
  memset(p, 0xbd, num_bytes);
  free(p);
}
```

*0xbdbdbdbd*에 접근한 시스템 에러가 발생하면 알 수 있겠죠?
 
### 상태 변이 에러

(원제 : State Transition Errors)

(역주 : 상태 변이 또는 상태 천이 에러에 대해서 감이 안오시면 다음 글을 읽어보세요 - [state transition Error](https://velog.io/@hyewon3938/%EB%94%94%EB%B2%84%EA%B9%85-Warning-Cannot-update-during-an-existing-state-transition-such-as-within-render.-Render-methods-should-be-a-pure-function-of-props-and-state))

대부분의 상태 변이(State Transition)에 관한 작업은 대부분 모범 사례가 존재하고, 자동화된 모듈이 존재하기 때문에 문제가 발생할 확률이 적습니다.<br>
이런 경우를 제외한다면 상태 머신(state machine)을 두고 시스템을 감시하는 것이 중요합니다.

`kState_Flushing`과 `kState_Committing` 두 가지 상태가 존재한다고 합시다.

Commit 상태는 반드시 Flush 상태 이후로 발생하는 것을 아래의 코드처럼 확인 할 수 있습니다.

```c
void on_commit(eState prev_state) {
  ASSERT(prev_state == kState_Flushing);
}
```

### 프로그래머에 의한 컴파일 타임 에러

정적인 환경에서 더 빠르게 실수를 발견하기 위해 `static_assert`를 이용할 수 잇습니다.

`static_assert`를 이용해서 제가 정의한 구조체가 일정 크기를 초과하지 않도록 늘 점검합니다.

```c
typedef struct {
  uint32_t count;
  uint8_t buf[12];
  uint8_t new_value;  // 새로 추가함
} MyStruct;

_Static_assert(sizeof(MyStruct) <= 16, "너무 큽니다!");
```

이 코드를 컴파일 하면 아래와 같이 나옵니다.

```
$ gcc test.c
test.c:14:1: error: static_assert failed due to requirement
    'sizeof(MyStruct) <= 16' "Oops, too large!"

_Static_assert(sizeof(MyStruct) <= 16, "Oops, too large!");
^              ~~~~~~~~~~~~~~~~~~~~~~
1 error generated.
```

정적으로 정의된 모든 것을 이와 같은 방식으로 검사할 수 있습니다.<br>
구조체, 열거형 데이터 타입(Enum), 문자열 길이, 등이 있겠네요.

추가로 데이터 타입인 구조체를 바꿀 때 동시에 문서화 작업을 하도록 유도하거나,<br>
변화에 대해서 이유를 서술하도록 메세지를 남기기도 합니다.

```c
_Static_assert(sizeof(MyStruct) == 16,
    "구조체의 크기를 바꾸려고 합니다! "
    "사내 문서 항목을 참조하거나 업데이트 해주세요 ..."
    "변경할 사항은 다음과 같은 진행 방식에 따라 진행해주세요 ...");
```

`static_assert`는 최종 릴리스에 출력되지 않으므로 자유롭게 사용하세요!

## 외부 입력 및 상황과 애플리케이션 코드 핸들링

공격적 프로그래밍을 하고 싶지 않은, 적절하지 않다고 판단되는 프로그램이 있습니다.

개발자가 프로그램, 하드웨어, 외부 입력 데이터, 등 전체적인 이해도가 떨어지는 경우가 있겠죠.

개발을 하면서 직접 다루는 소프트웨어 이외에 건들 수 없는 **외부 요인**에 대해 완벽한 이해도를 가지고 있지 않은 이상 

**정상적인 입력이 들어올것이라고 믿으면 안됩니다!**

다른 개발자들은 여러분이 작성하는 소프트웨어에 의도했건 안했건,<br>
가장 창의적이고, 아름답고, 끔찍하고, 위험한 행동을 할 것이기 때문에 항상 주의하고 있어야 합니다.

직접 손볼 수 있을 때(개발 중에) 이런 문제를 방지하기 위해서 외부의 위험한 것들로부터 일종의 보호막 역할을 해주는 것이 **방어적 프로그래밍**입니다.

방어적 프로그래밍은 릴리스 전까지 공격적 프로그래밍을 통해서 최대한 대응할 수 있는 모든 버그와 에러에 대한 해결책을 구상한 후,<br>
더 이상 상상 이상의 버그와 에러로부터 스스로를 보호할 수 있는 최후의 수단과 같은 것이죠.

마지막으로 이론 내용을 마무리 짓기전에, 모든 개발자와 개발자 단체는 늘 최선을 다할 것이고, 또 지향할 겁니다.<br>
모든 것을 의심하고 `assert`를 통해서 통제 가능한 선에서 모든 것을 확인하고, 유용한 메세지와 덤프를 띄우면서 스스로를 돕는 개발방법을 지향합시다.

## 모범 예시

### 부팅 시퀀스 단계에서는 관대해지세요

간단합니다, 부팅 시퀀스에 해당되는 코드에 `assert`를 하지 마세요.

부팅 과정 도중에 assertion이 발생하면 재부팅 루프에 빠져 아무 시도조차 할 수 없기 때문입니다.

저는 디바이스가 디버거에 직접 연결되어 있거나, 문제 발생확률이 거의 없어 릴리스를 할 때 부팅 시퀀스에 assert를 사용합니다.

물론 의심이 된다면, 도중에 발생하는 에러 로그를 기록하세요.

### Playing Offense Internally

디버거에 연결되어 있을 떄는 쉽게 디버깅을 할 수 있으니, 극한의 상황에 도전해보세요.

버그가 발생했음에도 조치를 안할 경우 어떤 일이 일어나는지 쉽게 트레이스백을 할 수 있으니<br>
조성된 환경 내에서는 실험적으로 테스트하는 것이 중요합니다.
    
### 릴리스 제품에서도 공격적 프로그래밍 적용하기

릴리스 제품에서도 공격적 프로그래밍이 개발에 있어 어떻게 작동하는지 알아보기 전에,<br>
소프트웨어가 다운될 경우 어떻게 발생한 문제가 어떤 방식으로 기록될지 정해야합니다.

문제가 발생하면 개발 단계처럼 시스템 자체를 중단하지말고 어딘가에 로그를 남기는 것이 당연하겠죠?

좋은 예로 [ARM MBed's Error Handling API](https://os.mbed.com/docs/mbed-os/v6.5/apis/error-handling.html)를 보면 펌웨어 계층마다 존재하는 에러 API를 이용해 개발자들이 원할 때 에러를 볼 수 있겠끔 설정해 놓는 것이 있습니다.

개발 단계에서의 ASSERT를 로깅하는 함수로 바꾸는 메크로를 이용하면 됩니다.

```c
#if PRODUCTION_BUILD
  #define MY_ASSERT(expr, msg)    \
    do {                          \
      if (!(expr)) {              \
        /* log error to buffer */ \
      }                           \
    } while (0)
#else
  #define MY_ASSERT(expr, msg)    \
    do {                          \
      if (!(expr)) {              \
        /* core dump */           \
      }                           \
    } while (0)
#endif
```

## 결론

공격적 프로그래밍은 성가신 것보다는 적극적으로 에러에 대해서 알려주고, 개발자로 하여금 더 빠르게 에러를 수정할 수 있는 기회를 제공합니다.

비록 간단하게 정리한 내용에 불과하지만, 공격적 프로그래밍을 사용하면 더 빠른 디버깅을 하실 수 있게될 겁니다.