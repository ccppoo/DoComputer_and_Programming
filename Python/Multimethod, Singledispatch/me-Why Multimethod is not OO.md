# Why Multimethod is not OO

[Five-minute Multimethods in Python](./Five-minute Multimethods in Python.md)을 읽으면서 내 눈에 가장 들어온 문구는 다음과 같았다.

(It also isn't very OO, but then, neither are multimethods, despite the name, IMO.) 

본문 내용에 참고만 하라고 넣은 괄호 속 내용이다.

우선 **객체지향적이다**라는 말을 쓸 때 가장 쉽게 판별하는 방법으로 책 \<오브젝트\>의 내용을 따와서 

'객체를 능동적이고 주체적인 존재로써 대하는가?'

라는 질문을 우선 던져봤다.

우선 멀티 메서드라는 것 자체가 나는 '객체지향적이다'라고 자신있게 말할 수 있는 스탠스(stance)는 아니지만, 그렇다고 부인하지 않은 이유는 아래와 같다.

----------

## 객체지향적이지 않을 수 있는 생각

### 인터페이스의 부재, 개방 폐쇄(open-close principle) 원칙

우선 함수를 떠나 객체 그 자체에 있어 인터페이스와 구현부가 분리되어 있지 않다.

언어 자체에 내장된 문법(괄호 `()`두개가 함수 이름 끝에 있는)을 사용할 뿐, 다른 객체들이 함수를 사용할 수 있는 정의된 인터페이스가 없다.

함수 자체를 인터페이스 객체(자바의 경우 인터페이스를 하나의 타입으로 취급해서 객체를 사용한다는 지)로써 볼 수 없다.

지정된 인자의 타입( `(int, int)`)을 맞춰야 사용가능하다.

`(int, int)` 타입 예시가 간단할 뿐, 만약 2개 이상의 다수의 인자를 요구하는 경우, 함수 내부 구성요소를 다른 객체가 알아야하는, 함수 내부 작동방식을 이해해야하는, 상황에 이를 수 있다.

즉, 함수를 이용하는 다른 객체는 메세지(Message)를 보내는 것이 아닌, 함수를 수동적인 존재로 만들어 객체간에 능동적인 상호작용을 저해한다. 

타입에 따라서 멀티메서드를 하나하나 추가하는 행위 자체가 `if-else` 문을 추가하는 것과 다름없다.<br>
단지 `if` 문이 없을 뿐 키값을 통해 함수를 조회하고  defualt 값이 없는 경우를 제외한 것이기 때문이다.

```python
def foo(a, b):
    if isinstance(a, int) and isinstance(n, int):
        # ...
    if isinstance(a, str) and isinstance(n, str):
        # ...
```<br>
([Five-minute Multimethods in Python](./Five-minute Multimethods in Python.md) 첫 예시)

(단일책임을 지지않는다고 볼 수 있나?)


## 객체지향적일 수 있는 생각

### 타입 상관없이 일방적으로 함수를 호출할 수 있는 사용자

함수가 어떤 타입의 인자를 받는지 인지만 한다면, 사용자 입장에서 함수에게 제한된 인자 타입 조합 내에서 자유롭게 호출(call)할 수 있다.

명확한 인터페이스는 아니지만, 인터페이스에 같은 이름의 함수를 오버로드(overload)하듯이 추가할 수 있다.

----------

이렇게 쓰다보니 객체지향적이지 않은 것같다("... isn't very OO")

단지 여러 단계의 if 문을 **syntax sugar**로 만든 것이라는게 느껴진다

객체지향 언어를 정적타입처럼 쓸거면 차라리 제네릭을 사용하거나, 인터페이스를 만드는 것이 객체지향적인 대안같다.